---
title: Web Server와 WAS
date: 2024-01-29 00:00:00 +0900
categories: [⚙️Back-End, 이론 및 개념]
tags: [Web,
WAS,
Web Server,
Server,
]     
---    
## 객체란?    

**객체**는 **객체 지향 프로그래밍의 가장 기본적인 단위이자 시작점**이다.  

>  **“모든 실재(實在)하는 대상”**  
>
> **"우리가 보고 느끼고 인지할 수 있는 그 모든 것"**    

## 객체 지향 프로그래밍(OOP)

객체 지향 프로그래밍(Object-Oriented-Programming, OOP)란 **여러 독립 부품(객체)들의 조합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임**이다.  

**'객체 지향적으로 프로그래밍한다'** : 어떤 프로그램의 일부분에 해당하는 작은 부품, 즉 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 하나의 완성된 프로그램을 만든다.  

---

## 객체지향 프로그래밍의 장점  

**1. ** 객체 지향적 설계를 통해서 **프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다.**

**2.**객체 지향적 원리를 잘 적용해 둔 프로그램은 각각의 객체들이 각자의 독립적인 역할을 가지기 때문에 **코드의 변경을 최소화하고 유지보수를 하는 데 유리**하다.    

**3.** **코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현** 할 수 있다.

**4.** 객체 지향 프로그래밍은 실제 우리가 보고 경험하는 세계를 최대한 프로그램 설계에 반영하기 위한 지속적인 노력을 통해 발전해 왔기 때문에, 보다 **인간 친화적이고, 직관적인 코드**를 작성하기에 용이하다.  

---

## 객체 지향 프로그래밍의 4가지 특징  

![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/db9b2421-53cb-4fad-a5e5-f753f8594112)  

### 1. 추상화(Abstraction)  

>  **“사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것”**  
>
> **“공통성과 본질을 모아 추출”**  

객체 지향 프로그래밍에서 의미하는 추상화는 **객체의 공통적인 속성과 기능을 추출하여 정의하는것**을 의미한다.

![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/17a308a7-c52a-4e32-83df-e8723d0f2741)  

예시로 `자동차(car)`와`오토바이(MotorBike)`는 모두 `이동수단(Vehicle)`이며 *전진과 후진*을 할 수 있다는 **공통점**을 가진다. 자바 문법 요소를 사용하면, `자동차(car)`와`오토바이(MotorBike)`는 **하위 클래스(Sub Class)**, `이동수단(Vehicle)`은 **상위 클래스(Super Class)**이다. `moveForward()`와 `moveBackward()`는 **공통적인 메서드(기능)**이다. 이 외에도 **공통적인 변수(속성)**도 선언 가능하다.  

  

자바에서 추상화를 구현할 수 있는 문법 요소로는 **추상 클래스(abstract class)**와 **인터페이스(interface)**가 있다.  

<div style = "text-align : center"> 이동수단(Vehicle) 인터페이스</div>  

``` java
public interface Vehicle{
    void start();
    void moveForward();
    void moveBackward();
}
```

 `자동차(car)`와`오토바이(MotorBike)`의 **공통적인 기능을 추출**하여 `이동수단(Vehicle)` **인터페이스**에 정의한다.  

> 인터페이스 : “서로 다른 두 시스템, 장치, 소프트웨어 따위를 서로 이어주는 부분 또는 그런 접속 장치”  

객체 지향적 설계에 있어서 인터페이스는 어떤 **객체의 역할만을 정의**하여 객체들 간의 관계를 보다 유연하게 연결하는 역할을 담당한다. **어떤 객체가 수행해야 하는 핵심적인 역할만을** **규정**해두고, **실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록** 프로그램을 설계하는 것을 의미한다.  

<div style = "text-align : center"> 자동차(Car) 클래스</div>  

```java
public class Car implements Vehicle{
    @Override
    public void moveForward(){
        System.out.println("자동차가 앞으로 전진합니다");
    }
    @Override
    public void movebackward(){
        System.out.println("자동차가 뒤로 후진합니다");
    }
}
```



<div style = "text-align : center"> 오토바이(MotorBike) 클래스</div>  

```java
public class MotorBike implements Vehicle{
    @Override
    public void moveForward(){
        System.out.println("오토바이가 앞으로 전진합니다");
    }
    @Override
    public void movebackward(){
        System.out.println("오토바이가 뒤로 후진합니다");
    }
}
```

 `자동차(car)`와`오토바이(MotorBike)`가 `이동수단(Vehicle)` **인터페이스에 정의한 공통된 역할**을 **각각의 클래스의 맥락에 맞게 구현**했다.  

이것을 객체 지향 프로그래밍에서는 **역할과 구현의 분리**라고 한다.  

객체 지향 프로그래밍에서는 **보다 유연하고 변경에 열려있는 프로그램을 설계하기 위해 역할과 구현을 분리**하는데, 여기서 역할에 해당하는 부분이 인터페이스를 통해 추상화될 수 있습니다.  

---

### 2. 상속(Inheritance)  

상속이란 **기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**를 의미한다.  

추상화의 연장선에서, 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 **상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용**할 수 있도록 합니다.  

**클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이** 딱 한 번만 정의해두고 간편하게 **재사용**할 수 있어 **반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근**하여 사용할 수 있도록 합니다.  

![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/352e86a7-f7fb-41cc-bcf6-5c419f5f2806)  

빨간색으로 표시된 속성과 기능들은 자동차와 오토바이의 공통적인 부분들이고, 푸른색으로 표시된 부분들은 그렇지 않은 부분들이다.  



<div style = "text-align : center"> 이동수단(Vehicle) 클래스</div>  

```java
public class Vehicle{
    String model;
    String color;
    int wheels;
    
    void moveForward(){
        System.out.println("전진합니다.");
    }
    void moveBackward(){
        System.out.println("후진합니다.");
    }
}

```

  

<div style = "text-align : center"> 자동차(Car) 클래스</div>  

```java
public class Car extends Vehicle{
    boolean isConvertible;
    
    void openWindow(){
        System.out.println("모든 창문을 엽니다.");
    }
}
```

  

<div style = "text-align : center"> 오토바이(MotorBike) 클래스</div>  

```java
public class MotorBike extends Vehicle{
    boolean isRaceble;
    
    @Override
    public void moveForward(){
        System.out.println("오토바이가 앞으로 전진합니다");
    }
    void stunt(){
        System.out.println("오토바이로 묘기를 부립니다.");
    }
}
```

  

<div style = "text-align : center"> Main 실행 클래스</div>  

```java
public class Main{
    public static void main(String[] args){
        
        // 객체 생성
        Car car = new Car();
        MotorBike motorBike = new MotorBike();
        
        // car 객체의 속성 정의
        car.model = "테슬라";
        car.color = "빨강색";
        
        System.out.println("나의 자동차는 " + car.color + " " + car.model + "입니다.");
        
        // 객체들의 기능 실행
        car.moveForward();
        motorBike.moveForward();
        motorBike.moveBackward();
    }
}
```

```
출력값
나의 자동차는 빨강색 테슬라입니다.
전진합니다.
오토바이가 앞으로 전진합니다.
후진합니다.
```

 `자동차(car)`와`오토바이(MotorBike)`클래스의 공통적인 변수(속성)과 메서드(기능)들을 추출(추상화)하여 `이동수단(Vehicle)`상위 클래스에 정의하였고, `extends`키워드를 통해 각각의 하위 클래스로 확장하여 해당 기능과 속성들을 **매번 반복적으로 정의해야 하는 번거로움을 제거**했다.또한, **공통적인 코드의 변경이 있는 경우** 상위 클래스에서 단 한 번의 수정으로 모든 클래스에 변경 사항이 반영될 수 있도록 만들었다.  

`오토바이(MotorBike)` 클래스처럼 각각의 클래스의 맥락에 맞게 **메서드 오버라이딩(method overriding)을 사용하여 내용을 재정의**할 수도 있다.  

<span style = "color : red">**상속**</span>의 경우 <span style = "color : red">**상위 클래스의 속성과 기능들을 하위 클래스에서 그대로 받아 사용하거나 오버라이딩을 통해 선택적으로 재정의하여 사용**</span>할 수 있는 반면, <span style = "color : blue">**인터페이스**</span>를 통한 구현은 반드시 <span style = "color : blue">**인터페이스에 정의된 추상 메서드의 내용이 하위 클래스에서 정의**</span>되어야 한다.  

결론적으로, **상속 관계의 경우 인터페이스를 사용하는 구현에 비해 추상화의 정도가 낮다**고 할 수 있습니다. <span style = "color : blue">**인터페이스**</span>가 역할에 해당하는 껍데기만 정의해두고,  <span style = "color : blue">**하위 클래스에서 구체적인 구현을 하도록 강제**</span>하는 것에 비해, <span style = "color : red">**상속 관계**</span>의 경우 상황에 따라 모든 구체적인 내용들을 정의해두고 하위 클래스에서는 그것을<span style = "color : red"> **단순히 일부만 가져다가 재사용**</span>할 수 있습니다.  

---

### 3. 다형성  

**다형성(多形性)**이란 한자 이름 그대로 **어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질**을 의미한다.  

![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/cbd46a61-d476-458c-b753-a49f5031eac5)  

객체 지향에서 다형성은**어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성**을 의미한다.

앞서 언급한 메서드 **오버라이딩**과 **오버로딩**도 다형성의 한 중요한 예시지만, 객체 지향의 맥락에서 이것보다 더 중요한 다형성의 정의는 이것이다.  

> 객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것이다.   

`이동 수단(Vehicle)`예시로 들어보면, `이동 수단(Vehicle)`은 `자동차(Car)`가 될 수도, `오토바이(MotorBike)`가 될 수도 있다. 다르게 표현해보면, **`자동차는 자동차이다.`** 라는 명제와 **`자동차는 이동수단이다.`**라는 명제는 모두 참이다.  

객체 지향 프로그래밍에서 **다형성**이란 앞서 설명한 **`이동 수단`** 과 같은 넓은 범위의 타입, 즉 상위 클래스 타입의 참조 변수로 그것과 관계있는 하위 클래스들을 참조할 수 있는 능력이다.  

<div style = "text-align : center"> Main 실행 클래스</div>  

```java
public class Main{
    public static void main(String[] args){
        
        // 원래의 객체 생성 방식
        Car car = new Car();
        MotorBike motorBike = new MotorBike();
        
        // 다형성을 활용한 객체 생성 방식 
        Vehicle car2 = new Car();
    }
}
```

위 코드를 통해, **상위클래스 타입의 참조변수로 하위클래스 객체를 참조하는 것**의 의미를 조금 더 구체적으로 이해할 수 있다.

> 왜 다형성을 활용한 방식이 유용하지?  

형성을 활용하면 **여러 종류의 객체를 배열로 다루는 일**이 가능해진다.  

```java
public class Main{
    public static void main(String[] args){
    	Vehicle vehicles[] = new Vehicle[2];
        vehicles[0] = new Car();
        vehicles[1] = new Car();
        
        for (Vehicle vehicle : vehicles){
            System.out.println(vehicle.getClass()); // 각각의 클래스를 호출해주는 메서드
        }
    }
}
```

```
출력값
class Car
class MotorBike
```

다형성을 활용하면 **하나의 타입만으로 여러 가지 타입의 객체를 참조**할 수 있어 보다 간편하고 유연하게 코드를 작성하는 것이 가능해진다.  

다른 예를 살펴보기 위해, 새로운 `Driver`클래스를 정의하겠다.

<div style = "text-align : center"> Driver 클래스</div>  

```java
public class Driver{
    void driver(Car car){
        car.moveForward();
        car.moveBackward();
    }
    
    void drive(MotorBike motorBike){
        motorBike.moveForward();
        motorBike.moveBackward();
    }
}
```



<div style = "text-align : center"> Main 실행 클래스</div>  

```java
public class Main{
    public static void main(String[] args){
        
        Car car = new Car();
        MotorBike motorBike = new MotorBike();
        Driver driver = new Driver();
        
        driver.drive(car);
        driver.drive(motorBike);
    }
}
```

```
출력값
전진합니다.
후진합니다.
오토바이가 앞으로 전진합니다.
후진합니다
```

 `Driver` 클래스의 코드는 매우 간단하다. 매개변수로 `자동차(Car)`나 `오토바이(MotorBike)`객체를 전달받아 운전하는 것이다. 이렇게 **하나의 객체가 다른 객체의 속성과 기능에 접근하여 어떤 기능을 사용**할 때, 우리는 **A클래스는 B클래스에 의존한다**라고 표현합니다.  

위 `Driver`클래스는  `자동차(Car)`, `오토바이(MotorBike)`와 직접적인 관계를 가지고 있는데, 이러한 경우를 **객체들간의 결합도가 높다**고 표현한다.  

하지만 이렇게 **결합도가 높은 상태는 객체 지향적인 설계를 하는 데 매우 불리**하다. `이동 수단(Vehicle)`이 `자동차(Car)`와 `오토바이(MotorBike)` 말고도 수 십, 수 백개면, 똑같은 코드를 수 십, 수 백 번 작성해야 할 것이다.  

또한, 만약 새로운 상황이 발생해, `오토바이`가 `(MotorBike)`가 아닌 `(MotorCycle)`클래스로 변경되야 하는 경우에는 `Driver`클래스 안에 매개변수로 전달되는 참조변수의 타입과 참조 변수를 수정해야 할 것이다.  

코드가 많아질수록 이 작업은 아주 고되고 힘든 작업이 될 수 밖에 것이다.  

이런 맥락에서, 객체 지향 프로그래밍은 **추상화, 상속, 그리고 다형성**의 특성을 활용하여 프로그래밍을 설계할 때 **역할**과 **구현을 구분**하여 객체들 간의 **직접적인 결합을 피하고, 느슨한 관계 설정**을 통해 보다 **유연하고 변경이 용이한 프로그램 설계**를 가능하게 만들었다. 이 부분이 객체 지향 프로그래밍의 핵심이다.  

<div style = "text-align : center"> 이동수단(Vehicle) 인터페이스</div>  

```java
public interface Vehicle{ // 이동 수단의 역할 정의
    void moveForward();
    void moveBackward();
}
```

<div style = "text-align : center"> 자동차(Car) 클래스</div>  

```java
public class Car implements Vehicle{
    @Override
    public void moveForward(){
        System.out.println("자동차가 앞으로 전진합니다");
    }
    @Override
    public void movebackward(){
        System.out.println("자동차가 뒤로 후진합니다");
    }
}
```



<div style = "text-align : center"> 오토바이(MotorBike) 클래스</div>  

```java
public class MotorBike implements Vehicle{
    @Override
    public void moveForward(){
        System.out.println("오토바이가 앞으로 전진합니다");
    }
    @Override
    public void movebackward(){
        System.out.println("오토바이가 뒤로 후진합니다");
    }
}
```

 

<div style = "text-align : center"> Driver 클래스</div>  

```java
public class Driver{
    void driver(Vehicle vehicle){
        vehicle.moveForward();
        vehicle.moveBackward();
    }
}
```



<div style = "text-align : center"> Main 실행 클래스</div>  

```java
public class Main{
    public static void main(String[] args){
        
        Car car = new Car();
        MotorBike motorBike = new MotorBike();
        Driver driver = new Driver();
        
        driver.drive(car);
        driver.drive(motorBike);
    }
}
```

```
출력값
자동차가 앞으로 전진합니다
자동차가 뒤로 후진합니다
오토바이가 앞으로 전진합니다
오토바이가 뒤로 후진합니다
```

한눈에 봐도 코드의 중복이 사라지고, 코드가 훨씬 간결해졌다는 사실을 알 수 있다.  

 `이동수단(Vehicle)` 인터페이스를 통해 이동 수단의 역할을 추상화하고, 각각 `자동차(Car)` 클래스와 `오토바이(MotorBike`) 클래스에서 기능들을 구현하고 있습니다. 

핵심은`Driver`클래스의  `drive()` 메서드로 전달되는 매개변수의 타입을 상위 클래스인 인터페이스 타입 `이동수단(Vehicle)` 로 변경한 것이다.  **다형성**의세례를 받은 `drive()` 메서드의 매개변수로 인터페이스를 구현한 객체라면 무엇이든 전달이 될 수 있게 되었다.