---
title: REST API(5) Event 생성 API 구현 - 입력값 제한하기
date: 2024-02-22 00:00:00 +0900
categories: [⚙️Back-End, 🍃Spring]
tags: [Spring,
RESTful,
REST,
API,
REST API,
RESTful API,
HATEOAS,
Self-descriptive,
]     
---  
## 구현 Package 및 Class  
![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/856df50f-cdfb-406a-8b84-1a3e75d9d43c)  
  
---  
## 입력값 제한하기  
우리는 이벤트를 등록하기에 앞서, **`Id`** 값은 자동으로 이벤트 등록시 자동으로 등록이 되야하고,  
**`free`** 무료인지 아닌지 여부, **`offline`** 오프라인인지 아닌지에 대한 여부 또한, 직접 등록이 아닌  
입력받은 데이터로 계산해서 등록이 되어야 하는 요소이다.  
이러한 입력값을 제한하기 위해, 우리는 입력 해야하는 값만을 다루는 **`DTO`**를 만들 것이다.  
  
### EventDTO 생성  
```java
package me.hantomas.restapi.events;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class EventDto {
    private String name;
    private String description;
    private LocalDateTime beginEnrollmentDateTime;
    private LocalDateTime closeEnrollmentDateTime;
    private LocalDateTime beginEventDateTime;
    private LocalDateTime endEventDateTime;
    private String location;
    private int basePrice;
    private int maxPrice;
    private int limitOfEnrollment;
}

```  
* 여기서는 **`@Data`**를 사용해줘도 된다.  
  
## EventController 수정  
```java
package me.hantomas.restapi.events;

import org.springframework.hateoas.MediaTypes;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import java.net.URI;

import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {
    private final EventRepository eventRepository;

    public EventController(EventRepository eventRepository){
        this.eventRepository = eventRepository;
    }
    @PostMapping
    public ResponseEntity createEvent(@RequestBody EventDto eventDto){
        
        Event event = Event.builder() 
                .name(eventDto.getName())
                .description(eventDto.getDescription())
//              ...
                .build(); // 추가

        Event newEvent = this.eventRepository.save(event);

        URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
        return ResponseEntity.created(createdUri).body(newEvent);
    }
}

```  
* **`EventDto`**를 객체로 사용하고 **`EventRepository`**로 DB에 저장하기 위해서는 **`EventDto`**를 **`Event`**객체로 변환 하는 과정이 필요하다. 그러기 위해서는 위 추가한 코드와 같이 데이터를 하나하나 변환해 주는 방법이 있지만, 이는 데이터가 많아질수록 변환해 줘야 하는 값도 많아짐을 의미한다.   
* 이를 한번에 가능하도록 하는 **`ModelMapper`**가 있다.  
  
---    
### pom.xml 수정  
```html
<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>2.3.1</version>
</dependency>
```  
* **`ModelMapper`**를 사용하기 위해 의존성을 추가해 준다.  

### RestApiApplication 수정  
```java
package me.hantomas.restapi;

import org.modelmapper.ModelMapper;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class RestApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(RestApiApplication.class, args);
	}

	@Bean
	public ModelMapper modelMapper(){
		return new ModelMapper();
	}
}

```  
* **`RestApiApplication`**에 **`ModelMapper`**를 빈으로 등록해 준다.  
  
### ModelMapper를 사용한 EventController 리팩토링  
```java
package me.hantomas.restapi.events;

import org.modelmapper.ModelMapper;
import org.springframework.hateoas.MediaTypes;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;

import java.net.URI;

import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;

@Controller
@RequestMapping(value = "/api/events", produces = MediaTypes.HAL_JSON_UTF8_VALUE)
public class EventController {
    private final EventRepository eventRepository;

    private final ModelMapper modelMapper; // 추가

    public EventController(EventRepository eventRepository, ModelMapper modelMapper){ // 추가
        this.eventRepository = eventRepository;
        this.modelMapper = modelMapper; // 추가
    }
    @PostMapping
    public ResponseEntity createEvent(@RequestBody EventDto eventDto){

        Event event = modelMapper.map(eventDto, Event.class); // 추가

        Event newEvent = this.eventRepository.save(event);

        URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
        return ResponseEntity.created(createdUri).body(newEvent);
    }
}

```  
* **`ModelMapper`**를 생성자 주입 방식으로 주입해준다.  
* `Event event = modelMapper.map(eventDto, Event.class);` : `eventDto`의 값을 **`Event`**클래스에 인스턴스로 만들어 준다.  
  
---  
## 결과 (오류)  
![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/8959254c-37c3-46a6-9fab-9ea47f953162)  
객체 변환도 잘 해줬는데 위와 같이 **NullPointException** 오류가 나고 말았다.  
그 이유는,  
```java
@PostMapping
public ResponseEntity createEvent(@RequestBody EventDto eventDto){

    Event event = modelMapper.map(eventDto, Event.class);

    Event newEvent = this.eventRepository.save(event);

    URI createdUri = linkTo(EventController.class).slash(newEvent.getId()).toUri();
    return ResponseEntity.created(createdUri).body(newEvent);
}
```  
**`EventController`**에서 우리가 `save()`에 전달한 객체는 `createEvent()` 메서드 내에서 새로 만들어준 객체다.
그래서 `Mockito.when(eventRepository.save(event)).thenReturn(event);`에서 Stubbing해준 **`event`**객체와 다르기 때문에 Mocking이 안되었고, 위와 같은 **NullPointException** 오류가 발생한 것이다.  
  
---  
## 오류 수정  
이를 해결하기 위해서는 더 이상 슬라이스 테스트가 아니여야 한다.  
```java
package me.hantomas.restapi.events;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.hamcrest.Matchers;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.hateoas.MediaTypes;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import java.time.LocalDateTime;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringRunner.class)
@SpringBootTest // 추가
@AutoConfigureMockMvc // 추가
//@WebMvcTest
public class EventControllerTests {
    @Autowired
    MockMvc mockMvc;
    @Autowired
    ObjectMapper objectMapper;
//  @MockBean
//  EventRepository eventRepository
    @Test
    public void createEvent() throws Exception{
        Event event = Event.builder()
                .id(100) // 추가
                .name("Spring")
                .description("REST API Development With Spring")
                .beginEnrollmentDateTime(LocalDateTime.of(2024,02,19,14,21))
                .closeEnrollmentDateTime(LocalDateTime.of(2024,02,20,14,21))
                .beginEventDateTime(LocalDateTime.of(2024,02,21,14,21))
                .endEventDateTime(LocalDateTime.of(2024,02,22,14,21))
                .basePrice(100)
                .maxPrice(200)
                .limitOfEnrollment(100)
                .location("강남역 D2 스타트업 팩토리")
                .free(true) // 추가
                .offline(false) // 추가
                .eventStatus(EventStatus.PUBLISHED) // 추가
                .build();
//      Mockito.when(eventRepository.save(event)).thenReturn(event);  

        mockMvc.perform(post("/api/events/")
                        .contentType(MediaType.APPLICATION_JSON_UTF8)
                        .accept(MediaTypes.HAL_JSON)
                        .content(objectMapper.writeValueAsString(event))
                )
                .andDo(print())
                .andExpect(status().isCreated())
                .andExpect(jsonPath("id").exists())
                .andExpect(header().exists(HttpHeaders.LOCATION))
                .andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaTypes.HAL_JSON_UTF8_VALUE))
                .andExpect(jsonPath("id").value(Matchers.not(100))) // 추가
                .andExpect(jsonPath("free").value(Matchers.not(true))) // 추가
                .andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name())) // 추가
        ;
    }
}

```  
* 더이상 슬라이스 테스트를 진행하지 않기 때문에 **`@WebMvcTest`**를 삭제하고, **`@SpringBootTest`**와 **`@AutoConfigureMockMvc`**를 추가해 준다. **`@SpringBootTest`**는 Mocking을 한 DispatcherServlet을 만들도록 하는 기본값들이 내재되어 있기 때문에 MockMvc로 계속해서 테스트가 가능하다.  
* **`@SpringBootTest`** 를 사용하면 애플리케이션을 실행했을 때와 가장 근사한 형태로 테스트를 수행할 수 있다. 실제 웹 테스트를 구현할 때는 **`@SpringBootTest`** 사용하는데, 그렇지 않으면 Mocking해줘야 할 것들이 너무 많아지기 때문이다. 
* Mocking에 관련된 것들은 삭제해준다.  
  
---  
## 결과 (성공)  
이렇게 하면 `id(100)` , `free(true)`, `offline(false)`,`eventStatus(EventStatus.PUBLISHED)`로 요청을 넣어 줬지만,  
**`Dto`**는  이 데이터들을 다루지 않기 때문에 이 입력들을 무시하게된다.  
따라서, `.andExpect(jsonPath("id").value(Matchers.not(100)))`,`.andExpect(jsonPath("free").value(Matchers.not(true)))`,`.andExpect(jsonPath("eventStatus").value(EventStatus.DRAFT.name()))`를 만족시키기 때문에 성공적인 응답값을 출력한다.  

![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/5aa10ae1-f51d-43fb-a38f-5748ba1c5e2f)   
![image](https://github.com/han-tomas/han-tomas.github.io/assets/124488773/1111b23b-d042-48cd-96fe-583d9af2b263)


